#/* $begin ncopy-ys */
##################################################################
# ncopy.ys - Copy a src block of len words to dst.
# Return the number of positive words (>0) contained in src.
#
# Include your name and ID here.
#Zhao Haoru
#520021910352
# Describe how and why you modified the baseline code.
#首先将原始程序中加8、减8、减1的操作都用iaddq指令替代，此时依然是0分；发现此时如果将条件跳转的指令
#放在对%rdx的加减操作后面时，可以省略andq指令；然后考虑循环展开，从四层循环展开开始考虑，尝试了四层、六层、八层循环
#展开，剩余元素直接循环，CPE分别为10.44、10.00、9.89（这个可能是处理完bubble的结果，记不清了），发现此时长度较小的测试集是效果提升的主要制约因素，于是开始考虑对剩余的元素
#进行处理，首先考虑了对于剩余元素再次进行循环展开，对剩余元素进行四路循环展开，发现效果并不好，此时发现在mrmovq与rmmovq之间由于read/load hazard存在bubble，
#在循环内一次读出两个元素来消除bubble的影响，然后考虑对于剩余元素的处理，使用跳转表直接展开，去掉了加减指令，最后上网查询到%rax的初始值是0，因此
#第一条指令可以去掉，在跳转表部分，bubble并没有处理
##################################################################
# Do not modify this portion
# Function prologue.
# %rdi = src, %rsi = dst, %rdx = len
.align 8
L0:
	.quad Done
	.quad L1  
	.quad L2
	.quad L3 
	.quad L4 
	.quad L5 
	.quad L6 
	.quad L7
ncopy:

##################################################################
# You can modify this portion
	# Loop header
	# xorq %rax,%rax		# count = 0;
	iaddq $-8, %rdx
	jl Pre_handle1

Loop:	
	mrmovq (%rdi), %r10	
	mrmovq 8(%rdi), %r9
	rmmovq %r10, (%rsi)
	andq %r10, %r10		# val <= 0?
	jle Loop1		# if so, goto Npos:
	iaddq $1, %rax 

Loop1:
	# mrmovq 8(%rdi), %r10	# read val from src...
	rmmovq %r9, 8(%rsi)	# ...and store it to dst
	andq %r9, %r9		# val <= 0?
	jle Loop2		# if so, goto Npos:
	iaddq $1, %rax 

Loop2:
	mrmovq 16(%rdi), %r10	# read val from src...
	mrmovq 24(%rdi), %r9	# read val from src...
	andq %r10, %r10		# val <= 0?
	rmmovq %r10, 16(%rsi)	# ...and store it to dst
	jle Loop3		# if so, goto Npos:
	iaddq $1, %rax 

Loop3:
	# mrmovq 24(%rdi), %r10	# read val from src...
	rmmovq %r9, 24(%rsi)	# ...and store it to dst
	andq %r9, %r9		# val <= 0?
	jle Loop4		# if so, goto Npos:
	iaddq $1, %rax 

Loop4:
	mrmovq 32(%rdi), %r10	# read val from src...
	mrmovq 40(%rdi), %r9	# read val from src...
	rmmovq %r10, 32(%rsi)	# ...and store it to dst
	andq %r10, %r10		# val <= 0?
	jle Loop5		# if so, goto Npos:
	iaddq $1, %rax 

Loop5:
	# mrmovq 40(%rdi), %r10	# read val from src...
	rmmovq %r9, 40(%rsi)	# ...and store it to dst
	andq %r9, %r9		# val <= 0?
	jle Loop6		# if so, goto Npos:
	iaddq $1, %rax 

Loop6:
	mrmovq 48(%rdi), %r10	# read val from src...
	mrmovq 56(%rdi), %r9	# read val from src...
	rmmovq %r10, 48(%rsi)	# ...and store it to dst
	andq %r10, %r10		# val <= 0?
	jle Loop7		# if so, goto Npos:
	iaddq $1, %rax 

Loop7:
	# mrmovq 56(%rdi), %r10	# read val from src...
	rmmovq %r9, 56(%rsi)	# ...and store it to dst
	andq %r9, %r9		# val <= 0?
	jle Npos		# if so, goto Npos:
	iaddq $1, %rax 


Npos:	
	iaddq $64, %rdi
	iaddq $64, %rsi
	iaddq $-8, %rdx
	jge Loop			# if so, goto Loop:	
	

Pre_handle1:
	iaddq $8, %rdx
	# je Done
	addq %rdx, %rdx
	addq %rdx, %rdx
	addq %rdx, %rdx
	mrmovq L0(%rdx), %rdx
	pushq %rdx
	ret

L7:
	mrmovq 48(%rdi), %r10	# read val from src...
	andq %r10, %r10		# val <= 0?
	rmmovq %r10, 48(%rsi)	# ...and store it to dst
	jle L6		# if so, goto Npos:
	iaddq $1, %rax 

L6:
	mrmovq 40(%rdi), %r10	# read val from src...
	andq %r10, %r10		# val <= 0?
	rmmovq %r10, 40(%rsi)	# ...and store it to dst
	jle L5		# if so, goto Npos:
	iaddq $1, %rax 

L5:
	mrmovq 32(%rdi), %r10	# read val from src...
	andq %r10, %r10		# val <= 0?
	rmmovq %r10, 32(%rsi)	# ...and store it to dst
	jle L4		# if so, goto Npos:
	iaddq $1, %rax 

L4:
	mrmovq 24(%rdi), %r10	# read val from src...
	andq %r10, %r10		# val <= 0?
	rmmovq %r10, 24(%rsi)	# ...and store it to dst
	jle L3		# if so, goto Npos:
	iaddq $1, %rax 

L3:
	mrmovq 16(%rdi), %r10	# read val from src...
	andq %r10, %r10		# val <= 0?
	rmmovq %r10, 16(%rsi)	# ...and store it to dst
	jle L2		# if so, goto Npos:
	iaddq $1, %rax 


L2:
	mrmovq 8(%rdi), %r10	# read val from src...
	andq %r10, %r10		# val <= 0?
	rmmovq %r10, 8(%rsi)	# ...and store it to dst
	jle L1		# if so, goto Npos:
	iaddq $1, %rax 

L1:
	mrmovq (%rdi), %r10	# read val from src...
	andq %r10, %r10		# val <= 0?
	rmmovq %r10, (%rsi)	# ...and store it to dst
	jle Done		# if so, goto Npos:
	iaddq $1, %rax 


Done:
	ret


##################################################################
# Keep the following label at the end of your function
End:
#/* $end ncopy-ys */
